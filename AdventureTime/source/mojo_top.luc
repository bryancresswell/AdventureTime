module mojo_top (
    input clk,              // 50MHz clock
    input rst_n,            // reset button (active low)
    //output led [8],         // 8 user controllable LEDs
    input cclk,             // configuration clock, AVR ready when high
    output spi_miso,        // AVR SPI MISO
    input spi_ss,           // AVR SPI Slave Select
    input spi_mosi,         // AVR SPI MOSI
    input spi_sck,          // AVR SPI Clock
    output spi_channel [4], // AVR general purpose pins (used by default to select ADC channel)
    input avr_tx,           // AVR TX (FPGA RX)
    output avr_rx,          // AVR RX (FPGA TX)
    input avr_rx_busy,      // AVR RX buffer full
    output io_led [3][8],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield
    output io_sel [4],      // Digit select on IO Shield
    input io_button [5],    // 5 buttons on IO Shield
    //input io_dip [3][8]     // DIP switches on IO Shield
    output a_seg [8],
    output a_sel [4],
    output b_seg [8],
    output b_sel [4],
    
    input enterbuttons,
    input buttons0,
    input buttons1,
    input buttons2,
    input buttons3,
    input buttons4,
    input buttons5,
    input buttons6,
    input buttons7,
    
    output op_seg [8]
  ) {
  sig rst;              // reset signal
  
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
    bin_to_dec digitsa (#DIGITS(4));
    bin_to_dec digitsb (#DIGITS(4));
         
    .rst(rst) {
      fsm states = {BEGIN, START, IDLE, SCORE, OVER};  
      fsm hp = {EIGHT, ONE, TWO, THREE, FOUR, FIVE, SIX, SEVEN};  
      pn_gen rngesus;
      multi_seven_seg msega;
      multi_seven_seg msegb;
      
      buttonCounter enterbutton;
      buttonCounter button0;
      buttonCounter button1;
      buttonCounter button2;
      buttonCounter button3;
      buttonCounter button4;
      buttonCounter button5;
      buttonCounter button6;
      buttonCounter button7;
    }    
    counter timingCounter (#SIZE(5), #TOP(20), #DIV(26));
  }
  
  sevenseg seg (.dot(0));
  operatorseg opseg;
  sig alu[8];  
  main alu1;  
  //sig p[8];
  sig a[8];
  sig b[8];
  sig sol[8];
  sig result[8];
  sig op[2];
  
  always {
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
    
    //led = 8h00;             // turn LEDs off
    spi_miso = bz;          // not using SPI
    spi_channel = bzzzz;    // not using flags
    avr_rx = bz;
    rngesus.seed = 0;
    rngesus.next = 0;
    io_led = 3x{{8h00}};    // turn LEDs off
    io_seg = 8hff;          // turn segments off
    io_sel = 4hf;              // select no digits
    
    timingCounter.rst = 1;        
    seg.char = 0;
    
    io_seg = ~seg.segs;
    io_sel = ~4h1;
      
    alu1.a = 0;
    alu1.b = 0;
    alu = alu1.alu;
    sol = 0;
    result = 0;
    
    a_seg = 8hff;           // turn off segs
    a_sel = 4hf;            // select no digits
    b_seg = 8hff;           // turn off segs
    b_sel = 4hf;            // select no digits
    
    alu1.alufn = 0; // Sets alufn, a and b as 0 values on initializing
    alu1.a = 0;
    alu1.b = 0;
    alu = alu1.alu;
    
    timingCounter.rst = 1;
    
    seg.char = 0;
    io_seg = ~seg.segs;
    io_sel = ~4h1;
    //// main code block for display from here to...
    //// input the a values into digitsa
    digitsa.value = 0; // collect a's values
    //// input the digit array into msega
    msega.values = digitsa.digits;    // convert a's values into an array of decimal numbers
    //// code block for displaying a
    a_seg = msega.seg;                // output multi seven seg into a_seg
    a_sel = ~msega.sel;               // cycles and shifts the numbers to display the required number
    
    //// rinse and repeat for msegb
    digitsb.value = 0;
    msegb.values = digitsb.digits;
    //// ...here
    b_seg = msegb.seg;
    b_sel = ~msegb.sel;
    
    button0.button = ~buttons0;
    button1.button = ~buttons1;
    button2.button = ~buttons2;
    button3.button = ~buttons3;
    button4.button = ~buttons4;
    button5.button = ~buttons5;
    button6.button = ~buttons6;
    button7.button = ~buttons7;
    button7.button = ~buttons7;
    enterbutton.button = ~enterbuttons;
    //io_led[1][0] = enterbutton.count;
    
    //inputer.button = buttons[7:0];
    //io_led[2] = inputer.value;
    
    opseg.char = 8hff;
    op_seg = opseg.segs;
    
    case(states.q){
      states.BEGIN:
        if (enterbutton.count){
          states.d = states.START;
        }
      states.START:
        timingCounter.rst = 0;
        seg.char = 20 - timingCounter.value;
        case (hp.q){
          hp.EIGHT: io_led[0] = 8b11111111;
          hp.SEVEN: io_led[0] = 8b01111111; 
          hp.SIX: io_led[0] = 8b00111111;
          hp.FIVE: io_led[0] = 8b00011111;
          hp.FOUR: io_led[0] = 8b00001111;
          hp.THREE: io_led[0] = 8b00000111;
          hp.TWO: io_led[0] = 8b00000011;
          hp.ONE: io_led[0] = 8b00000001;
        }
        op = rngesus.num[17:16];
        case (op) { // multiply   
          b01:
            io_led[1] = b000010;
            alu1.alufn = b000010;  // configures them to have these values now
            a = rngesus.num[3:0];
            b = rngesus.num[7:4];
            result = a * b;
          b00: // add block
            io_led[1] = b0000000;      
            alu1.alufn = b000000;
            a = rngesus.num[6:0];
            b = rngesus.num[14:8];
            result = a + b;
          b10:
            if (rngesus.num[7:0] < rngesus.num[15:8]) { // subtract block swap posoition if first 8 smaller than next 8 (prevent negatives)        
              alu1.alufn = b000001;
              a = rngesus.num[14:8];
              b = rngesus.num[6:0];
              result = a - b;
            } 
            else { // subtract block
              io_led[1] = b00001;       
              alu1.alufn = b000001;
              b = rngesus.num[15:8];
              a = rngesus.num[7:0];
              result = a - b;
            }
            default:
              alu1.alufn = b000000;
              a = rngesus.num[6:0];
              b = rngesus.num[13:7];  
              result = a + b; 
          }
          
          alu1.a = a;
          alu1.b = b;
          alu = alu1.alu;
          digitsa.value = a;
          digitsb.value = b;
          msega.values = digitsa.digits;
          msegb.values = digitsb.digits;
          a_seg = msega.seg;
          b_seg = msegb.seg;
          a_sel = ~msega.sel;
          b_sel = ~msegb.sel;
          
          opseg.char = op;
          op_seg = opseg.segs;
        
          button0.button = ~buttons0;
          io_led[2][0] = button0.count;
          button1.button = ~buttons1;
          io_led[2][1] = button1.count;
          button2.button = ~buttons2;
          io_led[2][2] = button2.count;
          button3.button = ~buttons3;
          io_led[2][3] = button3.count;
          button4.button = ~buttons4;
          io_led[2][4] = button4.count;
          button5.button = ~buttons5;
          io_led[2][5] = button5.count;
          button6.button = ~buttons6;
          io_led[2][6] = button6.count;
          button7.button = ~buttons7;
          io_led[2][7] = button7.count;
          button7.button = ~buttons7;
          io_led[2][7] = button7.count;
          enterbutton.button = ~enterbuttons;
        
          sol = (button0.count) + (button1.count << 1) + (button2.count << 2) + (button3.count << 3) + (button4.count << 4) + (button5.count << 5) + (button6.count << 6) + (button7.count << 7);
          
          //io_led[1][0] = enterbutton.count;
          if (io_button[0]){
            if (sol == result){states.d = states.IDLE;}
            else {io_led[2] = b11111111;}
          }
          else if (timingCounter.value == 20){
            states.d = states.SCORE;
          }
          //if (p == alu && io_button[3] == 1) (if this is correct)
          //if (io_button[1] == 1){
            //states.d = states.IDLE;
          //}
          //p != alu && io_button[3] == 1 || (remember to add the alu check and button)
          //else if (timingCounter.value == 20) {
              //states.d = states.SCORE;
          //}
        
      states.IDLE:
        if (enterbutton.count){ 
          states.d = states.START;
          rngesus.next = 1;
        }
      states.SCORE:
        if (hp.q == hp.ONE){
          states.d = states.OVER;
        }
        else{
          if (hp.q == hp.EIGHT){hp.d = hp.SEVEN;}
          else if (hp.q == hp.SEVEN){hp.d = hp.SIX;}
          else if (hp.q == hp.SIX){ hp.d = hp.FIVE;}
          else if (hp.q == hp.FIVE){hp.d = hp.FOUR;}
          else if (hp.q == hp.FOUR){hp.d = hp.THREE;}
          else if (hp.q == hp.THREE){hp.d = hp.TWO;}
          else if (hp.q == hp.TWO){hp.d = hp.ONE;}
          states.d = states.IDLE;
          //rngesus.next = 1;
        }
      states.OVER:
        io_led[0] = 8b11111111;
        io_led[1] = 8b11111111;
        io_led[2] = 8b11111111;
    }
  }  
}
